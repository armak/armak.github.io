<!DOCTYPE html>
<html>
<head>
	<style type="text/css">
		@font-face {
			font-family: 'Montserrat';
	    	src: url('fonts/Montserrat-SemiBold.ttf') format('truetype');
		}
		@font-face {
			font-family: 'MontserratLight';
	    	src: url('fonts/Montserrat-Light.ttf') format('truetype');
		}
		* {margin:0; padding:0;}
		html, body {width: 100%; height: 100%; background:#222222;}
		canvas {display: block; z-index: -1;}
		#wrapper{
			position:absolute;
			top: 50%;
			left: 0;
			width: 100%;
		}
		.text {
			position: block;
			top: 0;
			width: 100%;
			color: #eeeeee;
			user-select: none;
			transform: translateY(-5.5vw);
			animation: fadein 3s;
		}
		#title {
			text-align: center;
			font-size: min(7vw, 7em);
			font-family: 'Montserrat';
			text-shadow: 0px 0px 1.5px #eeeeee;
		}
		#disclaimer {
			font-size: min(1.4vw, 1.5em);
			font-family: 'MontserratLight';
			text-shadow: 0px 0px 1px #eeeeee;
			margin-left:50%;
			margin-top:-5.5%;
			width:12em;
			/* Bias centering slightly to not account for the ellipsis. */
			transform: translateX(-48%);
		}
		@keyframes fadein {
			from {opacity: 0;}
			to   {opacity: 1;}
		}
	</style>
</head>
<body>
		<canvas id="canvas"></canvas>
		<div id="wrapper">
			<h1 class="text" id="title">Anti Cryptoart</h1>
			<h2 class="text" id="disclaimer">under construction</h1>
		</div>
</body>

<script>
(function(){

	let frame = 0;
	setInterval(function(){
		let element = document.getElementById("disclaimer");
		switch(frame){
			case(0):
				element.textContent = "under construction";
				break;
			case(1):
				element.textContent = "under construction.";
				break;
			case(2):
				element.textContent = "under construction..";
				break;
			case(3):
				element.textContent = "under construction...";
				break;
			case(4):
				element.textContent = "under construction";
				break;
			case(5):
				element.textContent = "under construction";
				break;
			default:
				break;
		}
		frame = (frame+1) % 6;
	}, 200);

	let canvas = document.getElementById("canvas");
	let gl = canvas.getContext("webgl2");
	console.log(gl.getExtension('EXT_color_buffer_float'));
	console.log(gl.getExtension('OES_texture_float_linear'));
	
	function createShader(gl, sourceCode, type){
		let shader = gl.createShader(type);
		gl.shaderSource(shader, sourceCode);
		gl.compileShader(shader);
		gl.attachShader
		if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
			let info = gl.getShaderInfoLog( shader );
			throw 'Could not compile WebGL program. \n\n' + info;
		}
		return shader;
	}

	let vertex = `#version 300 es
in vec2 coords;
void main(){
	gl_Position = vec4(coords.xy, 0.0, 1.0);
}`;

	let fragment = `#version 300 es
// LICENSE:
// Creative Commons Attribution 4.0 International License.
// https://creativecommons.org/licenses/by/4.0/
// Based on original work by victor_shepardson
// https://www.shadertoy.com/view/XsSfWR
precision highp float;
uniform vec2 R;
uniform float Time;
uniform sampler2D PreviousFrame;
#define T(x) texture(PreviousFrame, fract((x)/R.xy))
out vec4 c;
void main(){
	vec2 u = gl_FragCoord.xy;
	c=u.yyyx/1e4;
	if(Time < 1.0){
		for(float t=1.5; t<50.; t+=t)
		c += c.gbar/mix(1.2, 3.9, smoothstep(0.0, 1.0, Time))-c*.3+T(u-c.wz*t);
	} else {
		for(float t=1.5; t<400.; t+=t)
			c += c.gbar/3.9-c*.3+T(u-c.wz*t);
	}
	c = mix(T(.5*R+.5*((-R+2.*u)*0.9984)), cos(c), mix(0.45, 0.034, sqrt(smoothstep(0.0, 1.0, Time))));
}`;

	let output = `#version 300 es
precision highp float;
uniform float Time;
uniform sampler2D Frame;
out vec4 c;
const uint k = 1103515245U;
vec3 hash(uvec3 x){
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;
    return vec3(x)*(1.0/float(0xffffffffU));
}
vec3 color_saturate(vec3 color, float a){
	return mix(vec3(dot(color, vec3(0.2126, 0.7152, 0.0722))), color, a);
}
void main(){
    c = .5+.5*texelFetch(Frame, ivec2(gl_FragCoord.xy),0);
    c.rgb = color_saturate(c.rgb, 0.0);
    c.rgb = mix(vec3(0.25), c.rgb, smoothstep(1.0, 3.0, Time));
    float n = hash(uvec3(gl_FragCoord.xy, 60.0*Time)).x;
    c.rgb = pow(smoothstep(0.2, 1.0, c.rgb)*vec3(0.95+0.1*n), vec3(1.0/2.2));
    c.a = 1.0;
}`

	let pid = gl.createProgram();
	let f = createShader(gl, fragment, gl.FRAGMENT_SHADER);
	let v = createShader(gl, vertex, gl.VERTEX_SHADER);
	gl.attachShader(pid, f);
	gl.attachShader(pid, v);
	gl.linkProgram(pid);

	let pid2 = gl.createProgram();
	let f2 = createShader(gl, output, gl.FRAGMENT_SHADER);
	let v2 = createShader(gl, vertex, gl.VERTEX_SHADER);
	gl.attachShader(pid2, f2);
	gl.attachShader(pid2, v2);
	gl.linkProgram(pid2);

	let array = new Float32Array([-1,  3, -1, -1, 3, -1]);
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
	let al = gl.getAttribLocation(pid, "coords");
	gl.vertexAttribPointer(al, 2, gl.FLOAT, false, 0, 0);
	gl.enableVertexAttribArray(al);

	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
	let al2 = gl.getAttribLocation(pid2, "coords");
	gl.vertexAttribPointer(al2, 2, gl.FLOAT, false, 0, 0);
	gl.enableVertexAttribArray(al2);

	let w, h, fb0, fb1, targetTexture0, targetTexture1;
	createTextures();
	function createTextures(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		w = canvas.width;
		h = canvas.height;

		gl.deleteFramebuffer(fb0);
		gl.deleteFramebuffer(fb1);
		gl.deleteTexture(targetTexture0);
		gl.deleteTexture(targetTexture1);

		const targetTextureWidth = w;
		const targetTextureHeight = h;
		targetTexture0 = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, targetTexture0);
		{
			const level = 0;
			const internalFormat = gl.RGBA32F;
			const border = 0;
			const format = gl.RGBA;
			const type = gl.FLOAT;
			const data = null;
			gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
										 targetTextureWidth, targetTextureHeight, border,
										 format, type, data);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		}
		fb0 = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, fb0);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture0, 0);

		targetTexture1 = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, targetTexture1);
		{
			const level = 0;
			const internalFormat = gl.RGBA32F;
			const border = 0;
			const format = gl.RGBA;
			const type = gl.FLOAT;
			const data = null;
			gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
										 targetTextureWidth, targetTextureHeight, border,
										 format, type, data);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		}
		fb1 = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, fb1);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture1, 0);
	}

	let source = 0;
	let resolutionLocation = gl.getUniformLocation(pid, "R");
	let timeLocation       = gl.getUniformLocation(pid, "Time");
	let timeLocation2      = gl.getUniformLocation(pid2, "Time");

	draw();

	function draw(time) {
		gl.viewport(0, 0, w, h);
		gl.clearColor(0, 0, 0, 0);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		time /= 1000;
		
		gl.useProgram(pid);
		gl.uniform2f(resolutionLocation, w, h);
		gl.uniform1f(timeLocation, time);

		switch(source)
		{
			case 0:
				gl.bindFramebuffer(gl.FRAMEBUFFER, fb0);
				gl.bindTexture(gl.TEXTURE_2D, targetTexture1);
				gl.drawArrays(gl.TRIANGLES, 0, 3);
				source = 1;

				gl.useProgram(pid2);
				gl.uniform1f(timeLocation2, time);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				gl.bindTexture(gl.TEXTURE_2D, targetTexture0);
				gl.drawArrays(gl.TRIANGLES, 0, 3);
				break;
			case 1:
				gl.bindFramebuffer(gl.FRAMEBUFFER, fb1);
				gl.bindTexture(gl.TEXTURE_2D, targetTexture0);
				gl.drawArrays(gl.TRIANGLES, 0, 3);
				source = 0;

				gl.useProgram(pid2);
				gl.uniform1f(timeLocation2, time);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				gl.bindTexture(gl.TEXTURE_2D, targetTexture1);
				gl.drawArrays(gl.TRIANGLES, 0, 3);
				break;
			default:
				break;
		}

		window.requestAnimationFrame(draw);
	}

	window.addEventListener('resize', createTextures);
})();
</script>
</html>